--[[
    PROMETHEUS BYPASS - ULTIMATE ROBLOX VERSION
    
    Esta vers√£o detecta e previne corrup√ß√£o intencional do c√≥digo.
    
    O Anti-Tamper est√° fazendo:
    1. Detectando tampering
    2. Corrompendo propositalmente o c√≥digo (syntax error)
    3. Causando erro de parsing antes da execu√ß√£o
    
    Solu√ß√£o: Hooks mais profundos + timing perfeito
]]

print("üîì Prometheus Ultimate Bypass - Loading...")

-- ============================================================================
-- DETEC√á√ÉO DE AMBIENTE
-- ============================================================================

local env_check = {
    is_roblox = game ~= nil,
    has_hookfunction = hookfunction ~= nil,
    has_setreadonly = setreadonly ~= nil,
    has_debug = debug ~= nil,
    executor = (identifyexecutor and identifyexecutor()) or "Unknown",
}

if not env_check.is_roblox then
    error("This bypass is for Roblox only!")
end

print("[‚úì] Roblox environment detected")
print("[‚úì] Executor:", env_check.executor)

-- ============================================================================
-- BACKUP IMEDIATO (ANTES DE TUDO)
-- ============================================================================

local ORIG = {
    -- Math
    math_random = math.random,
    math_randomseed = math.randomseed,
}

-- Debug (se dispon√≠vel)
if debug then
    ORIG.debug_getinfo = debug.getinfo
    ORIG.debug_getlocal = debug.getlocal
    ORIG.debug_getupvalue = debug.getupvalue
    ORIG.debug_setupvalue = debug.setupvalue
    ORIG.debug_traceback = debug.traceback
    ORIG.debug_sethook = debug.sethook
end

-- String
ORIG.string_char = string.char
ORIG.string_dump = string.dump
ORIG.string_gmatch = string.gmatch
ORIG.string_gsub = string.gsub
ORIG.string_sub = string.sub
ORIG.string_find = string.find

-- Core
ORIG.pcall = pcall
ORIG.error = error
ORIG.loadstring = loadstring
ORIG.setmetatable = setmetatable
ORIG.getmetatable = getmetatable
ORIG.tonumber = tonumber
ORIG.tostring = tostring
ORIG.type = type
ORIG.rawget = rawget
ORIG.rawset = rawset
ORIG.getfenv = getfenv
ORIG.setfenv = setfenv

print("[‚úì] Original functions backed up")

-- ============================================================================
-- ESTADO GLOBAL DO BYPASS
-- ============================================================================

local STATE = {
    active = true,
    verification_mode = true,
    start_time = tick(),
    hooks_installed = false,
    
    -- Contadores
    calls = {
        random = 0,
        getinfo = 0,
        error = 0,
        loadstring = 0,
    },
    
    -- Flags de detec√ß√£o
    detected = {
        syntax_corruption = false,
        early_error = false,
    },
}

-- ============================================================================
-- HOOK CR√çTICO: error (PREVENIR CORRUP√á√ÉO)
-- ============================================================================

local function hook_error()
    if hookfunction then
        ORIG.error = hookfunction(error, function(msg, level)
            STATE.calls.error = STATE.calls.error + 1
            
            -- Detectar tentativas de corrup√ß√£o
            if type(msg) == "string" then
                local msg_lower = string.lower(msg)
                
                -- Padr√µes de corrup√ß√£o intencional
                if msg_lower:find("expected") or 
                   msg_lower:find("did you forget") or
                   msg_lower:find("to close") then
                    
                    STATE.detected.syntax_corruption = true
                    print("[!] DETECTED: Syntax corruption attempt!")
                    
                    -- Bloquear o erro se estiver em verifica√ß√£o
                    if STATE.verification_mode then
                        print("[BYPASS] Blocking corruption error")
                        return  -- N√£o propagar o erro
                    end
                end
            end
            
            -- Propagarerro normal
            return ORIG.error(msg, level or 1)
        end)
        
        print("[‚úì] error() hooked (prevents corruption)")
    else
        warn("[!] Cannot hook error - corruption may occur")
    end
end

-- ============================================================================
-- HOOK: loadstring (PREVENIR INJE√á√ÉO DE C√ìDIGO CORROMPIDO)
-- ============================================================================

local function hook_loadstring()
    if hookfunction then
        ORIG.loadstring = hookfunction(loadstring, function(source, chunkname)
            STATE.calls.loadstring = STATE.calls.loadstring + 1
            
            -- Verificar se o c√≥digo tem syntax errors intencionais
            if type(source) == "string" and STATE.verification_mode then
                -- Detectar padr√µes suspeitos no c√≥digo
                if source:find("Expected") or 
                   source:find("did you forget to close") or
                   source:len() < 10 then  -- C√≥digo muito curto = suspeito
                    
                    print("[!] DETECTED: Corrupted code injection attempt!")
                    STATE.detected.syntax_corruption = true
                    
                    -- Retornar fun√ß√£o vazia ao inv√©s de c√≥digo corrompido
                    return function() end
                end
            end
            
            return ORIG.loadstring(source, chunkname)
        end)
        
        print("[‚úì] loadstring() hooked (prevents code injection)")
    end
end

-- ============================================================================
-- HOOK: math.random (CONTROLE TOTAL)
-- ============================================================================

local function hook_random()
    if hookfunction then
        math.random = hookfunction(math.random, function(min, max)
            STATE.calls.random = STATE.calls.random + 1
            
            -- Modo normal ap√≥s verifica√ß√£o
            if not STATE.verification_mode then
                if not min then return ORIG.math_random() end
                if not max then return ORIG.math_random(min) end
                return ORIG.math_random(min, max)
            end
            
            -- Modo verifica√ß√£o - controlar valores
            if not min and not max then
                return ORIG.math_random()
            end
            
            if not max then
                max = min
                min = 1
            end
            
            -- Estrat√©gia de bypass
            if STATE.calls.random == 1 and min == 3 and max == 65 then
                return 3  -- n = 3 (m√≠nimo)
            end
            
            if min == 1 and max == 2 then
                return 2  -- shouldErr = false
            end
            
            if min == 1 and max == 100 then
                return 10  -- len
            end
            
            if min == 0 and max == 255 then
                return 0  -- n2
            end
            
            if min == 1 and max >= 1 and max <= 100 then
                return 1  -- pos
            end
            
            if min == 0 and max >= 1000 then
                return 1000  -- linha erro
            end
            
            return min
        end)
        
        print("[‚úì] math.random() hooked (controlled)")
    end
end

-- ============================================================================
-- HOOK: debug.getinfo (FUN√á√ïES PARECEM C)
-- ============================================================================

local function hook_getinfo()
    if not debug or not hookfunction then return end
    
    debug.getinfo = hookfunction(debug.getinfo, function(func, what)
        STATE.calls.getinfo = STATE.calls.getinfo + 1
        
        if type(func) == "number" then
            return ORIG.debug_getinfo(func, what)
        end
        
        local result = ORIG.debug_getinfo(func, what)
        
        if result and STATE.verification_mode then
            -- Fazer todas as fun√ß√µes parecerem C
            result.what = "C"
            result.nups = nil
            result.nparams = nil
            result.isvararg = nil
            result.source = "=[C]"
        end
        
        return result
    end)
    
    print("[‚úì] debug.getinfo() hooked")
end

-- ============================================================================
-- HOOKS AUXILIARES
-- ============================================================================

local function hook_debug_functions()
    if not debug or not hookfunction then return end
    
    -- getlocal
    debug.getlocal = hookfunction(debug.getlocal, function(func, index)
        if STATE.verification_mode then
            return nil
        end
        return ORIG.debug_getlocal(func, index)
    end)
    
    -- getupvalue
    debug.getupvalue = hookfunction(debug.getupvalue, function(func, index)
        if STATE.verification_mode then
            return nil
        end
        return ORIG.debug_getupvalue(func, index)
    end)
    
    -- traceback
    debug.traceback = hookfunction(debug.traceback, function(msg, level)
        local result = ORIG.debug_traceback(msg, level)
        
        if STATE.verification_mode and type(msg) == "string" then
            return msg .. "\n:1:\n:1:\n:1:"
        end
        
        return result
    end)
    
    -- sethook
    debug.sethook = hookfunction(debug.sethook, function(hook, mask, count)
        if STATE.verification_mode and hook then
            return ORIG.debug_sethook(function(event, line)
                if hook then hook(event, line) end
            end, mask, count)
        end
        return ORIG.debug_sethook(hook, mask, count)
    end)
    
    print("[‚úì] Debug functions hooked")
end

local function hook_string_functions()
    if not hookfunction then return end
    
    -- string.dump
    string.dump = hookfunction(string.dump, function(func)
        if STATE.verification_mode then
            ORIG.error("unable to dump given function", 0)
        end
        return ORIG.string_dump(func)
    end)
    
    -- string.gmatch
    string.gmatch = hookfunction(string.gmatch, function(str, pattern)
        if STATE.verification_mode and pattern == ":(%d*):" then
            local count = 0
            return function()
                count = count + 1
                if count <= 25 then return "1" end
                return nil
            end
        end
        return ORIG.string_gmatch(str, pattern)
    end)
    
    print("[‚úì] String functions hooked")
end

-- ============================================================================
-- INSTALAR TODOS OS HOOKS
-- ============================================================================

local function install_all_hooks()
    if STATE.hooks_installed then
        return
    end
    
    print("\n[INSTALLING HOOKS...]")
    
    -- Ordem cr√≠tica: error e loadstring PRIMEIRO!
    hook_error()
    hook_loadstring()
    
    -- Depois os outros
    hook_random()
    hook_getinfo()
    hook_debug_functions()
    hook_string_functions()
    
    STATE.hooks_installed = true
    
    print("[‚úì] All hooks installed!\n")
end

-- ============================================================================
-- TIMER PARA DESATIVAR MODO VERIFICA√á√ÉO
-- ============================================================================

local function setup_timer()
    task.spawn(function()
        -- Esperar tempo suficiente para verifica√ß√µes
        task.wait(3)
        
        STATE.verification_mode = false
        
        print("\n" .. string.rep("=", 50))
        print("[‚úì] VERIFICATION MODE ENDED")
        print(string.rep("=", 50))
        print("\n[STATS]")
        print("  ‚Ä¢ math.random calls:", STATE.calls.random)
        print("  ‚Ä¢ debug.getinfo calls:", STATE.calls.getinfo)
        print("  ‚Ä¢ error calls:", STATE.calls.error)
        print("  ‚Ä¢ loadstring calls:", STATE.calls.loadstring)
        
        if STATE.detected.syntax_corruption then
            print("\n[!] Syntax corruption was detected and blocked!")
        end
        
        print("\n[‚úì] Bypass fully active - hooks in passive mode")
        print(string.rep("=", 50) .. "\n")
    end)
end

-- ============================================================================
-- MAIN EXECUTION
-- ============================================================================

install_all_hooks()
setup_timer()

-- ============================================================================
-- FINAL STATUS
-- ============================================================================

print(string.rep("=", 50))
print("‚úÖ PROMETHEUS ULTIMATE BYPASS LOADED")
print(string.rep("=", 50))

print("\n[FEATURES]")
print("  ‚úì Error corruption prevention")
print("  ‚úì Loadstring injection blocking")
print("  ‚úì Math.random control")
print("  ‚úì Debug function spoofing")
print("  ‚úì String function hooks")
print("  ‚úì Auto-disable after verification")

print("\n[PROTECTION]")
print("  ‚úì Blocks syntax error injection")
print("  ‚úì Prevents code corruption")
print("  ‚úì Intercepts error() calls")
print("  ‚úì Validates loadstring() input")

print("\n‚ö†Ô∏è  READY!")
print("Execute your obfuscated script now.")
print(string.rep("=", 50) .. "\n")

-- Retornar controle
return {
    state = STATE,
    original = ORIG,
    restore = function()
        -- Restaurar fun√ß√µes originais se necess√°rio
        if hookfunction then
            hookfunction(error, ORIG.error)
            hookfunction(math.random, ORIG.math_random)
            hookfunction(loadstring, ORIG.loadstring)
            if debug then
                hookfunction(debug.getinfo, ORIG.debug_getinfo)
            end
        end
        print("[‚úì] Functions restored")
    end
}
