-- Serviços e variáveis iniciais
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local character = player.Character or player.CharacterAdded:Wait()
local Camera = game.Workspace.CurrentCamera
local RunService = game:GetService("RunService")

local espEnabled = false
local espLines = {}
local espColor = Color3.fromRGB(255, 255, 255)
local ESP_Window = nil
local ESP_Ativo = false
local originalPosition = nil
local isFrozen = false


-- Cria a ScreenGui e define como pai (use game.CoreGui ou PlayerGui conforme preferir)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DeltaExecutorGui"
screenGui.Parent = game.CoreGui  -- ou: game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Cria a janela principal (MainFrame)
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 400, 0, 300)
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
mainFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
mainFrame.BorderSizePixel = 1
mainFrame.Parent = screenGui
mainFrame.Active = true      -- necessário para receber input
mainFrame.Draggable = true   -- torna a janela arrastável
mainFrame.BackgroundTransparency = 0.5  -- Deixa 50% transparente (0 = opaco, 1 = totalmente invisível)

-- Cria a barra de título
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundColor3 = Color3.fromRGB(5, 5, 5)
titleLabel.Text = "By JhonaDev139"
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.Parent = mainFrame

-- Painel Esquerdo para Categorias
local leftPanel = Instance.new("Frame")
leftPanel.Name = "LeftPanel"
leftPanel.Size = UDim2.new(0, 120, 1, -30)
leftPanel.Position = UDim2.new(0, 0, 0, 30)
leftPanel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
leftPanel.BorderSizePixel = 1
leftPanel.Parent = mainFrame
leftPanel.BackgroundTransparency = 0.3  -- 50% transparente

-- Layout para organizar os botões de categorias com espaçamento
local leftLayout = Instance.new("UIListLayout")
leftLayout.Parent = leftPanel
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0, 5)  -- espaçamento de 5 pixels

-- Painel Direito para Ações
local rightPanel = Instance.new("Frame")
rightPanel.Name = "RightPanel"
rightPanel.Size = UDim2.new(1, -120, 1, -30)
rightPanel.Position = UDim2.new(0, 120, 0, 31)
rightPanel.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
rightPanel.BorderSizePixel = 1
rightPanel.Parent = mainFrame
rightPanel.BackgroundTransparency = 0.3

-- Layout para organizar os botões de ações com espaçamento
local rightLayout = Instance.new("UIListLayout")
rightLayout.Parent = rightPanel
rightLayout.SortOrder = Enum.SortOrder.LayoutOrder
rightLayout.Padding = UDim.new(0, 5)

-- Função genérica para criar um botão (usado tanto para categorias quanto para ações)
 local function createButton(parent, buttonName, actionFunction)
    local btn = Instance.new("TextButton")
    btn.Name = buttonName
    btn.Size = UDim2.new(1, -10, 0, 30)  -- largura com margem e altura de 30 pixels
    btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    btn.Text = buttonName
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.Parent = parent
    btn.Background.Transparency = 0.3

    if actionFunction then
        btn.MouseButton1Click:Connect(actionFunction)
    end
 end
local function createButton(parent, text, onClick)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = UDim2.new(1, -10, 0, 30)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.SourceSans
    button.TextSize = 14
    button.Parent = parent
    button.MouseButton1Click:Connect(onClick)
    return button
end

local function createHoldButton(parent, text, onHoldStart, onHoldStop)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = UDim2.new(1, -10, 0, 30)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.SourceSans
    button.TextSize = 14
    button.Parent = parent

    button.MouseButton1Down:Connect(onHoldStart)
    button.MouseButton1Up:Connect(onHoldStop)

    return button
end

local speedToggle = false       -- false: velocidade normal; true: velocidade aumentada
local normalSpeed = 16          -- Velocidade padrão do Roblox
local boostedSpeed = 100        -- Velocidade "autá" (aumentada)
local isJumpIncreased = false -- Variável para controlar o estado do pulo

-- permite que o jogador pule no ar
local allowAirJump = false -- Variável para controlar o estado
local jumped = false -- Variável para detectar o pulo

local allowAirJump = false -- Controla se o jogador pode pular no ar
local collisionEnabled = true
local antAFKEnabled = false
local line = nil  
local connection = nil  
local espActive = false


-- Tabela que armazena as categorias e suas respectivas ações
local categories = {
    ["Player"] = {
        {name = "Speed", func = function()
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                if not speedToggle then
                    humanoid.WalkSpeed = boostedSpeed
                    speedToggle = true
                    print("Velocidade aumentada para " .. boostedSpeed)
                else
                    humanoid.WalkSpeed = normalSpeed
                    speedToggle = false
                    print("Velocidade normal restaurada (" .. normalSpeed .. ")")
                end
            else
                warn("Humanoid não encontrado!")
            end
        end},

        {name = "Inf jump", func = function()
            allowAirJump = not allowAirJump -- Alterna o estado
            print("Pulo no ar " .. (allowAirJump and "ativado" or "desativado"))
        end},

        {name = "Super jump", func = function()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                if isJumpIncreased then
                    humanoid.JumpPower = 50 -- Valor padrão do Roblox
                else
                    humanoid.JumpPower = 150 -- Super pulo
                end
                isJumpIncreased = not isJumpIncreased -- Alterna o estado
            end
        end},
        


-- Função do botão de voo
{name = "Fly", func = function()
    local character = game.Players.LocalPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not rootPart then 
        print("HumanoidRootPart não encontrado")
        return 
    end

    -- Cria uma ScreenGui exclusiva para os controles de Fly
    local flyScreenGui = Instance.new("ScreenGui")
    flyScreenGui.Parent = game.CoreGui

    -- Cria a janela do Fly
    local flyWindow = Instance.new("Frame", flyScreenGui)
    flyWindow.Size = UDim2.new(0, 200, 0, 300)
    flyWindow.Position = UDim2.new(0.8, 0, 0.2, 0)
    flyWindow.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    flyWindow.Active = true
    flyWindow.Draggable = true

    -- Título da janela
    local titleLabel = Instance.new("TextLabel", flyWindow)
    titleLabel.Text = "Fly Controls"
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = 18

    -- Container para os botões, posicionado abaixo do título
    local buttonContainer = Instance.new("Frame", flyWindow)
    buttonContainer.Size = UDim2.new(1, 0, 1, -30)
    buttonContainer.Position = UDim2.new(0, 0, 0, 30)
    buttonContainer.BackgroundTransparency = 1

    local layout = Instance.new("UIListLayout", buttonContainer)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0, 10)

    local flying = true
    local flySpeed = 50
    local movement = {up = 0, forward = 0}
    local flyConnection

    -- Loop para atualizar a velocidade do personagem enquanto estiver voando
    flyConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if flying then
            local camera = workspace.CurrentCamera
            local direction = camera.CFrame.LookVector * movement.forward
            local vertical = Vector3.new(0, movement.up, 0)
            rootPart.Velocity = (direction + vertical) * flySpeed
        end
    end)

    -- Botões de clique contínuo (hold) para controlar o movimento
    createHoldButton(buttonContainer, "+Y (go up)", 
        function() movement.up = 3 end, 
        function() movement.up = 0 end
    )
    createHoldButton(buttonContainer, "-Y (down)", 
        function() movement.up = -3 end, 
        function() movement.up = 0 end
    )
    createHoldButton(buttonContainer, "Forward", 
        function() movement.forward = 3 end, 
        function() movement.forward = 0 end
    )
    createHoldButton(buttonContainer, "Backward", 
        function() movement.forward = -3 end, 
        function() movement.forward = 0 end
    )

    -- Botão para parar o Fly e fechar a janela
    createButton(buttonContainer, "Stop Fly", function()
        flying = false
        if flyConnection then 
            flyConnection:Disconnect() 
        end
        flyScreenGui:Destroy()
        rootPart.Velocity = Vector3.new(0, 0, 0)
    end)
end},


{name = "Colision", func = function()
    
    -- Função para alternar a colisão do personagem
    local function toggleCollision()
        collisionEnabled = not collisionEnabled
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = collisionEnabled
            end
        end
    end

    -- Alterna a colisão imediatamente quando o botão for pressionado
    toggleCollision()
    end},
    
    {name = "Ant-AFK", func = function()
    

-- Função para mostrar a notificação
local function showNotification(message)
    local notification = Instance.new("TextLabel")
    notification.Size = UDim2.new(0, 300, 0, 50)
    notification.Position = UDim2.new(0.5, -150, 0.1, 0)  -- Exibido na parte superior centralizada
    notification.Text = message
    notification.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    notification.TextColor3 = Color3.fromRGB(255, 255, 255)
    notification.TextSize = 20
    notification.TextStrokeTransparency = 0.8
    notification.Parent = game.CoreGui

    -- Remover a notificação após 3 segundos
    wait(3)
    notification:Destroy()
end

-- Função para manter o jogador ativo e impedir o AFK
local function preventAFK()
    while antAFKEnabled do
        -- Movimenta o jogador para evitar ser kikado
        player.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 0.1) 
        wait(10)  -- Repite a movimentação a cada 10 segundos
    end
end
end},
    },-- Fechamento da tabela "Player"
    
    ["Visual"] = {
        {name = "Targeting Circle", func = function() 
            if circle then  
        circle:Remove()  -- Remove o círculo existente  
        circle = nil  

        if connection then  
            connection:Disconnect()  -- Para de atualizar o círculo  
            connection = nil  
        end  
        return  -- Sai da função para evitar recriar o círculo imediatamente  
    end  

    circle = Drawing.new("Circle")  
    circle.Thickness = 2  
    circle.Color = Color3.fromRGB(255, 0, 0)
    circle.Radius = 10  -- Ajuste o raio conforme necessário
    circle.Filled = false
    connection = RunService.RenderStepped:Connect(function()
        local closestPlayer = nil  
        local closestDist = math.huge  

        for _, otherPlayer in pairs(Players:GetPlayers()) do  
            if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Head") then  
                local targetPos, onScreen = Camera:WorldToViewportPoint(otherPlayer.Character.Head.Position)
                
                if onScreen then  
                    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)  
                    local targetScreenPos = Vector2.new(targetPos.X, targetPos.Y)  
                    local dist = (screenCenter - targetScreenPos).Magnitude  

                    if dist < closestDist then  
                        closestDist = dist  
                        closestPlayer = otherPlayer  
                    end  
                end  
            end  
        end  

        if closestPlayer then  
            local targetPos = Camera:WorldToViewportPoint(closestPlayer.Character.Head.Position)  
            circle.Position = Vector2.new(targetPos.X, targetPos.Y)  
            circle.Visible = true  
        else  
            circle.Visible = false  
        end  
    end)
end},
        {name = "Tergeting Line", func = function() 
        if line then  
        line:Remove()  -- Remove a linha existente  
        line = nil  

        if connection then  
            connection:Disconnect()  -- Para de atualizar a linha  
            connection = nil  
        end  
        return  -- Sai da função para evitar recriar a linha imediatamente  
    end  

    line = Drawing.new("Line")  
    line.Thickness = 2  
    line.Color = Color3.fromRGB(255, 0, 0)  

    connection = RunService.RenderStepped:Connect(function()  
        local closestPlayer = nil  
        local closestDist = math.huge  

        for _, otherPlayer in pairs(Players:GetPlayers()) do  
            if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then  
                local targetPos, onScreen = Camera:WorldToViewportPoint(otherPlayer.Character.HumanoidRootPart.Position)  
                
                if onScreen then  
                    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)  
                    local targetScreenPos = Vector2.new(targetPos.X, targetPos.Y)  
                    local dist = (screenCenter - targetScreenPos).Magnitude  

                    if dist < closestDist then  
                        closestDist = dist  
                        closestPlayer = otherPlayer  
                    end  
                end  
            end  
        end  

        if closestPlayer then  
            local targetPos = Camera:WorldToViewportPoint(closestPlayer.Character.HumanoidRootPart.Position)  
            line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)  
            line.To = Vector2.new(targetPos.X, targetPos.Y)  
            line.Visible = true  
        else  
            line.Visible = false  
        end  
    end)  
end},

{name = "ESP name", func = function()
    
    local espNameColor = Color3.new(1, 1, 1) -- Cor padrão branca
    local player = game.Players.LocalPlayer
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")

    -- Função para criar ou atualizar ESP Name
    local function updateESPName(target)
        if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = target.Character.HumanoidRootPart
            local label = hrp:FindFirstChild("ESPLabel")

            if not label then
                label = Instance.new("BillboardGui", hrp)
                label.Size = UDim2.new(0, 70, 0, 10)
                label.Adornee = hrp
                label.AlwaysOnTop = true
                label.Name = "ESPLabel"

                local frame = Instance.new("Frame", label)
                frame.Size = UDim2.new(1, 0, 1, 0)
                frame.BackgroundTransparency = 1

                local textLabel = Instance.new("TextLabel", frame)
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.Text = target.Name
                textLabel.TextColor3 = espNameColor
                textLabel.BackgroundTransparency = 1
                textLabel.TextScaled = true
                textLabel.Name = "ESPText"
            end
        end
    end

    -- Função para remover todos os ESP Names
    local function removeESPNames()
        for _, target in pairs(Players:GetPlayers()) do
            if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = target.Character.HumanoidRootPart
                local label = hrp:FindFirstChild("ESPLabel")
                if label then
                    label:Destroy()
                end
            end
        end
    end

    -- Função principal do botão (ativa/desativa ESP)
    if espEnabled then
        -- Se já estiver ativado, desativa
        removeESPNames()
        espEnabled = false
        print("ESP Name Desativado")
    else
        -- Se estiver desativado, ativa
        for _, target in pairs(Players:GetPlayers()) do
            if target ~= player then
                updateESPName(target)
            end
        end
        espEnabled = true
        print("ESP Name Ativado")
    end
end},

{name = "Esp Line", func = function()
local function UpdateESP()
    if espEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = player.Character.HumanoidRootPart
                local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

                if onScreen then
                    if not espLines[player] then
                        espLines[player] = Drawing.new("Line")
                        espLines[player].Thickness = 2
                        espLines[player].Color = espColor
                    end
                    espLines[player].From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    espLines[player].To = Vector2.new(screenPos.X, screenPos.Y)
                    espLines[player].Visible = true
                else
                    if espLines[player] then
                        espLines[player].Visible = false
                    end
                end
            end
        end
    else
        for _, line in pairs(espLines) do
            line:Remove()
        end
        espLines = {}
    end
end

RunService.RenderStepped:Connect(UpdateESP)

    espEnabled = not espEnabled
end},

{name = "Chams", func = function()



-- Função para alternar o estado do ESP
local function toggleESP()
    espActive = not espActive -- Alterna entre verdadeiro e falso
    if espActive then
        print("ESP Ativado")
        -- Aqui você pode colocar a lógica para ativar o ESP
    else
        print("ESP Desativado")
        -- Aqui você pode colocar a lógica para desativar o ESP
    end
end

-- Função para criar o botão
local function createESPButton()
    local espButton = Instance.new("TextButton")
    espButton.Text = "Ativar/Desativar ESP"
    espButton.Size = UDim2.new(0, 200, 0, 50)
    espButton.Position = UDim2.new(0, 10, 0, 10)
    espButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    espButton.Parent = game.CoreGui

    espButton.MouseButton1Click:Connect(function()
        toggleESP()  -- Alterna o ESP ao clicar
        -- Muda o texto do botão dependendo do estado do ESP
        if espActive then
            espButton.Text = "Desativar ESP"
        else
            espButton.Text = "Ativar ESP"
        end
    end)
end

-- Cria o botão
createESPButton()

end},

    }, -- FECHAR A CATEGORIA
    -- Adicione novas categorias e suas ações aqui!
},
    

-- Evento para permitir o pulo no ar (fora da tabela do botão)
game:GetService("UserInputService").JumpRequest:Connect(function()
    local character = game.Players.LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid and allowAirJump then
            if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping) -- Permite pular no ar
            end
        end
    end
end)



-- Função para limpar os botões de ação existentes no painel direito
local function clearRightPanel()
    for _, child in ipairs(rightPanel:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
end

-- Função para carregar as ações de uma categoria no painel direito
local function loadActions(categoryName)
    clearRightPanel()
    local actions = categories[categoryName]
    if actions then
        for _, action in ipairs(actions) do
            createButton(rightPanel, action.name, action.func)
        end
    end
end

-- Função para criar os botões de categorias no painel esquerdo
local function loadCategories()
    for categoryName, _ in pairs(categories) do
        createButton(leftPanel, categoryName, function()
            loadActions(categoryName)
        end)
    end
end

-- Inicializa os botões de categorias e carrega uma categoria padrão (a primeira encontrada)
loadCategories()
for categoryName, _ in pairs(categories) do
    loadActions(categoryName)
    break
end